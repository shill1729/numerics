# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

akkadianRootF <- function(x, a) {
    .Call(`_numerics_akkadianRootF`, x, a)
}

#' The inferred method of Akkadian-Babylonian mathematicians to approximate
#' square roots
#'
#' @param a the number to compute square root of
#' @param n the number of iterations to take in the method
#'
#' @description {For finding the square-root of whole numbers.}
#' @details {The algorithm is on wikipedia and quite straightforward.}
#' @export akkadianRoot
akkadianRoot <- function(a, n = 100L) {
    .Call(`_numerics_akkadianRoot`, a, n)
}

#' Thomas algorithm for solving tridiagonal linear systems. Stability only for diagonally dominant or symmetric positive definite.
#'
#' @param a lower diagonal of matrix
#' @param b diagonal of matrix
#' @param c upper diagonal of matrix
#' @param d vector on RHS of equation
#'
#' @description {Thomas algorithm for tridiagonal linear systems. This can be used to solve
#' PDEs arising from Feynman-Kac connections.}
#' @details {The algorithm is on wikipedia and quite straightforward.}
#' @export thomas_algorithm
thomas_algorithm <- function(a, b, c, d) {
    .Call(`_numerics_thomas_algorithm`, a, b, c, d)
}

#' Newton-Raphson algorithm for solving optimal log utiltiy under uniform distributions
#'
#' @param interval the interval for the uniform distribution
#' @param rate the risk-neutral rate
#' @param n the number of iterations to take in the NR method.
#'
#' @description {For finding the root of the function \eqn{h(x)=\log((1+bx)/(1+ax))/(b-a)-x}.}
#' @details {The algorithm is on wikipedia and quite straightforward.}
#' @export uniform_log_util
uniform_log_util <- function(interval, rate = 0.0, n = 500L) {
    .Call(`_numerics_uniform_log_util`, interval, rate, n)
}

